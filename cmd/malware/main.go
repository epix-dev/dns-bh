package main

import (
	"bufio"
	"crypto/tls"
	"database/sql"
	"flag"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/epix-dev/dns-bh/lib"

	_ "github.com/lib/pq"
)

var (
	version = "dev"
	build   = "none"
	author  = "undefined"
)

type malware struct {
	ID     int
	Domain string
	Reason string
	Source string
}

func arrayContaintsMalware(a malware, list []malware) bool {
	for _, b := range list {
		if b.Domain == a.Domain && b.Source == a.Source && b.Reason == a.Reason {
			return true
		}
	}

	return false
}

func loadPositions(url string, items *[]malware) error {
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: false},
	}
	client := &http.Client{Transport: tr}

	resp, err := client.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	scanner := bufio.NewScanner(resp.Body)
	scanner.Split(bufio.ScanLines)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		if !strings.HasPrefix(line, "#") {
			data := strings.Split(line, "\t")

			*items = append(*items, malware{0, data[0], data[1], data[2]})
		}
	}

	log.Printf("loaded %d entries from: %s", len(*items), url)

	return nil
}

func updateItems(db *sql.DB, items []malware) []string {
	var result []string

	inserSQL := `
	INSERT INTO malware (
		domain,
		reason,
		source,
		created_at
	) values($1, $2, $3, CURRENT_TIMESTAMP)
	`

	updateSQL := "UPDATE malware SET updated_at = CURRENT_TIMESTAMP WHERE domain = $1 AND reason = $2 AND source = $3"

	insertStmt, err := db.Prepare(inserSQL)
	lib.CheckError(err)
	defer insertStmt.Close()

	updateStmt, err := db.Prepare(updateSQL)
	lib.CheckError(err)
	defer updateStmt.Close()

	for _, item := range items {
		updateRes, err := updateStmt.Exec(item.Domain, item.Reason, item.Source)
		lib.CheckError(err)

		if affect, _ := updateRes.RowsAffected(); affect == 0 {
			_, err := insertStmt.Exec(item.Domain, item.Reason, item.Source)
			lib.CheckError(err)
			log.Printf("added %s:%s", item.Domain, item.Source)
			result = append(result, item.Domain)
		}
	}

	return result
}

func deleteItems(db *sql.DB, items []malware) []string {
	var result []string

	var positions []malware

	for _, item := range items {
		positions = append(positions, item)
	}

	selectSQL := "SELECT id, domain, reason, source FROM malware WHERE deleted_at IS NULL"
	updateSQL := "UPDATE malware SET deleted_at = CURRENT_TIMESTAMP WHERE deleted_at IS NULL AND id = $1"

	updateStmt, err := db.Prepare(updateSQL)
	lib.CheckError(err)
	defer updateStmt.Close()

	rows, err := db.Query(selectSQL)
	lib.CheckError(err)

	for rows.Next() {
		var entry malware

		err = rows.Scan(&entry.ID, &entry.Domain, &entry.Reason, &entry.Source)
		lib.CheckError(err)

		if !arrayContaintsMalware(entry, positions) {
			_, err := updateStmt.Exec(entry.ID)
			lib.CheckError(err)
			log.Printf("marked %s:%s as deleted", entry.Domain, entry.Source)
			result = append(result, entry.Domain)
		}
	}

	return result
}

func main() {
	var err error
	var db *sql.DB

	var cfgDir string
	var cfg lib.Config
	var domains []malware

	program := filepath.Base(os.Args[0])

	log.Printf("%s started, version: %s+%s, author: %s\n", program, version, build, author)

	flag.StringVar(&cfgDir, "cfg-dir", "/opt/dns-bh/etc", "Config dir path")
	flag.Parse()

	lib.ConfigInit(cfgDir)
	if !lib.ConfigLoad(&cfg) {
		os.Exit(1)
	}

	db, err = lib.ConnectDb(cfg.DB.Host, cfg.DB.Port, cfg.DB.User, cfg.DB.Password, cfg.DB.Name)
	if err != nil {
		log.Fatalln(err)
	}
	defer db.Close()

	if err := loadPositions("http://mirror1.malwaredomains.com/files/domains.txt", &domains); err != nil {
		log.Fatalln(err)
	}

	lib.ReportChanges(&cfg, updateItems(db, domains), "Added malware domains")
	lib.ReportChanges(&cfg, deleteItems(db, domains), "Deleted malware domains")
}
